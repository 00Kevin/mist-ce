stages:
  - discover
  - build
  - deploy
  - test
  - undeploy
  - release

variables:
  DEPLOY_DOMAIN_SUFFIX: -community.clear.glass
  TEST_DEPLOY_DOMAIN_SUFFIX: -community-test.clear.glass


discover submodules:
  stage: discover
  image: alpine
  before_script:
    - apk add --no-cache git
  script:
    - |
        git submodule status | \
          sed 's/^[ +-]\([0-9a-f]*\) \([^ ]*\).*$/\1,\2/' > submodules.csv
  artifacts:
    paths:
      - submodules.csv
    expire_in: 10 days


.docker_image: &docker_image_template
  stage: build
  image: docker:git
  services:
    - docker:dind
  variables:
    DOCKER_DRIVER: overlay2
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - |
        if [ -n "$EXT_REGISTRY" ]; then
          if [ -n "$EXT_REGISTRY_USER" ] && [ -n "$EXT_REGISTRY_PASSWORD" ]; then
            echo "Will log in to $EXT_REGISTRY."
            docker login -u $EXT_REGISTRY_USER -p $EXT_REGISTRY_PASSWORD $EXT_REGISTRY
          else
            echo "EXT_REGISTRY specified without EXT_REGISTRY_USER & EXT_REGISTRY_PASSWORD"
            /bin/false
          fi
          if [ -z "$EXT_REGISTRY_IMAGE" ]; then
            export EXT_REGISTRY_IMAGE="$EXT_REGISTRY/$CI_PROJECT_NAME"
          fi
        else
          export EXT_REGISTRY_IMAGE=""
        fi
        echo "EXT_REGISTRY_IMAGE=$EXT_REGISTRY_IMAGE"
    - |
        function docker_pull() {
          # docker_pull <img> : Will retry several times to pull image.
          img=$1
          tries=60
          sleep=10
          echo "Will try to pull image $img ($tries tries, ${sleep}s sleep)."
          for i in $(seq 1 $tries); do
            if docker pull $img; then
              echo "Image $img pulled successfully!"
              return 0
            fi
            sleep $sleep
          done
          echo "Failed too pull image $img."
          return 1
        }
    - |
        function docker_push() {
          # docker_push <src> <dest>: Retag and push image
          # <src> must be the full name of a local image.
          # <dest> must be just the image identifier, registry and tag will be
          # added automatically.
          src=$1
          for pref in $CI_REGISTRY_IMAGE $EXT_REGISTRY_IMAGE; do
            for suff in $CI_COMMIT_SHA $CI_COMMIT_REF_SLUG; do
              dest=$pref/$2:$suff
              echo "Tagging image $src as $dest..."
              docker tag $src $dest
              echo "Pushing image $dest..."
              docker push $dest
            done
          done
        }
    - |
        function get_submodule_sha() {
          cat submodules.csv | grep ",$1$" | cut -d, -f1
        }
    - |
        function docker_retag() {
          repo=$1
          img=$2
          src_img="$img:$(get_submodule_sha $repo)"
          docker_pull $src_img
          docker_push $src_img $repo
        }
  dependencies:
    - discover submodules

.retag_mist_image: &retag_image_template
  <<: *docker_image_template
  variables:
    DOCKER_DRIVER: overlay2
    GIT_STRATEGY: none

retag landing:
  <<: *retag_image_template
  script:
    - docker_retag landing mist/landing

retag ui:
  <<: *retag_image_template
  script:
    - docker_retag ui mist/ui

retag tests:
  <<: *retag_image_template
  script:
    - docker_retag tests mist/tests_base

build api:
  <<: *docker_image_template
  script:
    - SRC_IMG="mist/mist:$(get_submodule_sha api)"
    - docker_pull $SRC_IMG
    - |
        docker build \
          -t $CI_PROJECT_NAME/api:$CI_COMMIT_SHA \
          -f Dockerfile.api \
          --build-arg FROM_IMAGE=$SRC_IMG \
          --build-arg CC_VERSION_SHA=$CI_COMMIT_SHA \
          --build-arg CC_VERSION_NAME=$CI_COMMIT_REF_NAME \
          .
    - docker_push $CI_PROJECT_NAME/api:$CI_COMMIT_SHA api

build nginx:
  <<: *docker_image_template
  script:
    - |
        docker build \
          -t $CI_PROJECT_NAME/nginx:$CI_COMMIT_SHA \
          -f Dockerfile.nginx \
          .
    - docker_push $CI_PROJECT_NAME/nginx:$CI_COMMIT_SHA nginx

compose:
  stage: build
  image: python:alpine
  before_script:
    - pip install docker-compose
    - apk add --no-cache gettext
  script:
    - mkdir -p artifacts
    - |
        if [ -n "$EXT_REGISTRY_IMAGE" ]; then
          export IMG_REGISTRY=$EXT_REGISTRY_IMAGE
        elif [ -n "$EXT_REGISTRY" ]; then
          export IMG_REGISTRY="$EXT_REGISTRY/$CI_PROJECT_NAME"
        else
          export IMG_REGISTRY=$CI_REGISTRY_IMAGE
        fi
    - export IMG_TAG=$CI_COMMIT_REF_SLUG
    - echo "IMG_REGISTRY=$IMG_REGISTRY"
    - echo "IMG_TAG=$IMG_TAG"
    - envsubst < docker-compose.yml > artifacts/docker-compose.yml
  artifacts:
    paths:
      - artifacts/docker-compose.yml
  dependencies: []


.deploy_template: &deploy_template
  stage: deploy
  image: dtzar/helm-kubectl
  before_script:
    - |
        set -e
        function deploy() {
          export namespace="$1"
          touch values.yaml
          export host=$(echo $CI_ENVIRONMENT_URL | sed 's/^https\?:\/\/\(.*\)/\1/')
          kubectl describe namespace/$namespace || \
            kubectl create namespace $namespace

          export image_secret_name=
          if [[ "$CI_PROJECT_VISIBILITY" != "public" ]]; then
            kubectl create secret --namespace $namespace \
              docker-registry gitlab-registry \
              --docker-server=$CI_REGISTRY \
              --docker-username=${REGISTRY_USER:-$CI_REGISTRY_USER} \
              --docker-password=${REGISTRY_PASSWORD:-$CI_REGISTRY_PASSWORD} \
              --docker-email=$GITLAB_USER_EMAIL \
              -o yaml --dry-run | \
                kubectl replace --namespace $namespace --force -f -
            export image_secret_name=gitlab-registry
          fi

          export tls_secret_name=
          if [ -n "$TLS_KEY" ] && [ -n "$TLS_CRT" ]; then
            tls_tmpdir=$(mktemp -d)
            echo "$TLS_KEY" > $tls_tmpdir/tls.key
            echo "$TLS_CRT" > $tls_tmpdir/tls.crt
            kubectl create secret --namespace $namespace \
              tls https \
              --key $tls_tmpdir/tls.key \
              --cert $tls_tmpdir/tls.crt \
              -o yaml --dry-run | \
                kubectl replace --namespace $namespace --force -f -
            export tls_secret_name=https
            rm -rf $tls_tmpdir
          fi

          helm upgrade --install --namespace $namespace \
            -f values.yaml \
            --set image.tag="$CI_COMMIT_SHA" \
            --set image.repository="$CI_REGISTRY_IMAGE" \
            --set image.pullPolicy=IfNotPresent \
            --set image.secrets[0].name="$image_secret_name" \
            --set http.host=$host \
            --set http.tlsSecret=$tls_secret_name \
            $namespace ./chart/
          apk add --no-cache curl
          echo "Waiting for environment to be ready..."
          while kubectl --namespace $namespace get pods | grep -v NAME | grep -v Running; do
            sleep 5 && echo '.'
          done
          while !(curl -sSLf "$CI_ENVIRONMENT_URL"); do
            sleep 2 && echo 'Environment not ready yet...'
          done
        }
  script:
    - echo "$values" > values.yaml
    - deploy $namespace
  dependencies: []

deploy test:
  <<: *deploy_template
  environment:
    name: test/$CI_COMMIT_REF_NAME
    url: http://$CI_COMMIT_REF_SLUG$TEST_DEPLOY_DOMAIN_SUFFIX
    on_stop: undeploy test
  variables:
    namespace: test-$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG
    values: |
      clearglass:
        enableDevUsers: true

.deploy_review_template: &deploy_review_template
  <<: *deploy_template
  variables:
    namespace: $CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG
    values: |
      clearglass:
        enableDevUsers: true
      smtp:
        host: smtp.sendgrid.net
        port: 2525
        starttls: true
        username: apikey
        password: $SMTP_PASSWORD

deploy review:
  <<: *deploy_review_template
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: http://$CI_COMMIT_REF_SLUG$DEPLOY_DOMAIN_SUFFIX
    on_stop: undeploy review
  except:
    - master
  when: manual

deploy master:
  <<: *deploy_review_template
  environment:
    name: master
    url: http://master$DEPLOY_DOMAIN_SUFFIX
  only:
    - master

.test_template: &test_template
  stage: test
  image: $CI_REGISTRY_IMAGE/tests:$CI_COMMIT_SHA
  variables:
    GIT_STRATEGY: none
    MIST_URL: http://$CI_COMMIT_REF_SLUG$TEST_DEPLOY_DOMAIN_SUFFIX
    DISPLAY: ":1.0"
    REGISTER_USER_BEFORE_FEATURE: "True"
    EMAIL: thingirl.tester.mist.io+${CI_JOB_ID}@gmail.com
  before_script:
    - 'export TEST=$(echo "$CI_JOB_NAME" | cut -d/ -f1 | cut -d: -f2,3 | tr : /)'
    - echo "Test argument is $TEST"
    - echo "Image used is $CI_REGISTRY_IMAGE/tests:$CI_COMMIT_SHA"
    - echo $TEST_SETTINGS | base64 -d > test_settings.py
  dependencies: []

.api_test_template: &api_test_template
  <<: *test_template
  script:
    - /mist.tests/prepare_env.py --api -s /mist.tests/misttests/integration/api/$TEST.py

.ui_test_template: &ui_test_template
  <<: *test_template
  script:
    - /mist.tests/prepare_env.py -k --stop --tags=$TEST /mist.tests/misttests/integration/gui/core/pr/features
  artifacts:
    paths:
      - js_console.log
      - artifacts/error.png
      - artifacts/output.mp4
    expire_in: 3 days
    when: on_failure
  tags:
    - shm

API:io:api_token: *api_test_template
API:io:clouds: *api_test_template
# API:io:dns: *api_test_template
API:io:keys: *api_test_template
API:io:images: *api_test_template
API:io:machines: *api_test_template
API:io:networks: *api_test_template
API:io:schedules: *api_test_template
API:io:scripts: *api_test_template
API:io:rbac: *api_test_template
API:io:ip_whitelisting: *api_test_template

UI:clouds-actions: *ui_test_template
# UI:images-networks: *ui_test_template
UI:keys: *ui_test_template
UI:machines-1/2:
  <<: *ui_test_template
  retry: 1
UI:machines-2/2: *ui_test_template
UI:rbac-teams: *ui_test_template
UI:schedulers-1/2: *ui_test_template
UI:schedulers-2/2: *ui_test_template
UI:scripts: *ui_test_template
UI:user-actions:
  <<: *ui_test_template
  allow_failure: true
UI:ip-whitelisting:
  <<: *ui_test_template
  allow_failure: true
UI:zones:
  <<: *ui_test_template
  retry: 1


.undeploy_template: &undeploy_template
  stage: undeploy
  image: dtzar/helm-kubectl
  variables:
    GIT_STRATEGY: none
  before_script:
    - |
        set -e
        function undeploy() {
          helm delete --purge "$1" || true
          kubectl delete namespace "$1" || true
        }
  script:
    - undeploy $namespace
  allow_failure: true
  dependencies: []

undeploy test:
  <<: *undeploy_template
  environment:
    name: test/$CI_COMMIT_REF_NAME
    action: stop
  variables:
    namespace: test-$CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG

undeploy review:
  <<: *undeploy_template
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  variables:
    namespace: $CI_PROJECT_NAME-$CI_COMMIT_REF_SLUG
  when: manual
  except:
    - master


release:
  stage: release
  image: alpine
  variables:
    GIT_STRATEGY: none
    RELEASE_NOTES: |
      ## Installation

      Download the [docker-compose file]($CI_PROJECT_URL/builds/artifacts/$CI_COMMIT_REF_NAME/raw/artifacts/docker-compose.yml?job=compose),
      save it as `docker-compose.yml` and and run `docker-compose up -d`.

      Also see the [README]($CI_PROJECT_URL/blob/master/README.md) instructions.
  before_script:
    - apk add --no-cache curl jq
  script:
    - API_URL="https://gitlab.com/api/v4/projects/$CI_PROJECT_ID"
    - TAG_URL="$API_URL/repository/tags/$CI_COMMIT_TAG"
    - 'req() { curl -sSLf -H "Private-Token: $GITLAB_API_TOKEN" "$@"; }'
    - |
        if [ "$(req $TAG_URL | jq -r '.release')" = "null" ]; then
          echo "Release doesn't already exist, will create."
          METHOD=POST
        else
          echo "Release already exists, will update."
          METHOD=PUT
        fi
    - req -X $METHOD "$TAG_URL/release" --data-urlencode "description=$RELEASE_NOTES"
    - echo "Successfully updated gitlab release notes."
  only:
    - tags
  dependencies: []
